# name: CI/CD Pipeline

# on:
#   push:
#     branches:
#       - main
#       - staging
      
#   pull_request:
#     branches:
#       - main
#       - staging

# jobs:
#   test:
#     runs-on: ubuntu-latest
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4

#       - name: Set up Go
#         uses: actions/setup-go@v5
#         with:
#           go-version: '1.23.2'

#       - name: Install dependencies
#         run: |
#           go mod tidy  # Ensure the go.mod and go.sum files are up-to-date
#           go get -v ./...
#       - name: Install the application
#         run: go install ./...

#       - name: Run tests
#         run: go test -v ./... || exit 1  # Fail the job if tests fail

#   # Build the application and upload artifact
#   build:
#     runs-on: ubuntu-latest
#     needs: test  # Build job only runs after tests pass
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4

#       - name: Build the application
#         run: go build -v -o dist/main ./...

#       - name: Upload build artifact
#         uses: actions/upload-artifact@v4
#         with:
#           name: go-build-artifact
#           path: dist/main
#           if-no-files-found: warn

#       - name: Checking artifact
#         run: |
#           ls -la
#           tree dist

#   # Docker build, push to registry.
#   docker_build_push:
#     runs-on: ubuntu-latest
#     needs: build  # Docker build & push only runs after build succeeds
#     steps:
#       - name: Checkout code
#         uses: actions/checkout@v4

#       - name: Set up Docker Buildx
#         uses: docker/setup-buildx-action@v3

#       # - name: Docker login to Docker Hub
#       #   uses: docker/login-action@v3
#       #   with:
#       #     username: ${{ secrets.DOCKERHUB_USERNAME }}
#       #     password: ${{ secrets.DOCKERHUB_TOKEN }}

#       - name: Read version from VERSION file
#         id: read_version
#         run: |
#           if [ -f VERSION ]; then
#             VERSION=$(cat VERSION | xargs)
#             echo "VERSION=$VERSION" >> $GITHUB_ENV
#           else
#             echo "VERSION file not found!"
#             exit 1
#           fi
#       - name: Build and push Docker image
#         run: |
#           docker build -t manisankardivi/new:${{ env.VERSION }} .
#           FORMATTED_DATE=$(date +v%Y.%m.%d)
#           echo "$FORMATTED_DATE"
          
#   release-tag:
#     runs-on: ubuntu-latest
#     needs: docker_build_push
#     steps:
#       - name: shell script for Release & Tag
#         run: |
#             TODAY=$(date +%Y-%m-%d) 
#             PATCH=1  # Example patch version, adjust dynamically if needed (e.g., increment for each build)
            
#             # Check for any changes in the repository (you can adjust this to check specific files or services)
#             CHANGED_FILES=$(git diff --name-only $GITHUB_SHA^ $GITHUB_SHA)  # Adjust for your CI/CD environment
            
#             # Check if any files were modified
#             if [ -z "$CHANGED_FILES" ]; then
#               echo "No changes detected. Skipping version tag creation."
#               exit 0
#             fi
name: Auto Increment Tag & Create Release

on:
  push:
    branches:
      - main

jobs:
  release:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Git
        run: |
          git config user.name "Your Name"
          git config user.email "youremail@example.com"

      - name: Get the latest tag and increment
        id: tag
        run: |
          # Get the latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0)
          DATE_TAG=$(date +'%Y.%m.%d')
          TAG_SUFFIX=${LATEST_TAG#v$DATE_TAG.}
          NEW_TAG="v$DATE_TAG.$((TAG_SUFFIX + 1))"
          echo "NEW_TAG=$NEW_TAG" >> $GITHUB_ENV
          
          # Create and push the new tag
          git tag "$NEW_TAG"
          git push origin "$NEW_TAG"

      - name: Create new release
        run: |
          curl -X POST https://api.github.com/repos/${{ github.repository }}/releases \
            -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
            -d '{
              "tag_name": "'${{ env.NEW_TAG }}'",
              "name": "'${{ env.NEW_TAG }}'",
              "body": "Release notes for changes.",
              "draft": false,
              "prerelease": false,
              "target_commitish": "main"
            }'
